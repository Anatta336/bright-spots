using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

class BrightSpotsPass : ScriptableRenderPass
{
  // used to label this pass in Unity's Frame Debug utility
  string profilerTag;

  ComputeShader brightsCompute;
  Material flareMaterial;
  ComputeBuffer brightsBuffer;
  ComputeBuffer drawArgsBuffer;

  // These are needed in Execute but aren't directly available there, so store.
  // But be aware they're not guaranteed valid after the current pass is complete.
  RenderTargetIdentifier cameraColorIdent;
  RenderTargetIdentifier cameraDepthIdent;
  RenderTextureDescriptor cameraTextureDescriptor;
  float luminanceThreshold;
  bool drawDirect;
  bool drawIndirect;

  RenderTexture renderTexture;

  int recentCount;
  public int RecentCount
  {
    get { return recentCount; }
  }

  // store these so we only have to look them up once
  int findBrightsKernel,
    colourTexID,
    textureSizeXID,
    textureSizeYID,
    brightQuadsID,
    luminanceThresholdID;
  int groupSizeX, groupSizeY;

  public BrightSpotsPass(string profilerTag,
    RenderPassEvent renderPassEvent, ComputeShader brightsCompute,
    Material flareMaterial, RenderTexture renderTexture)
  {
    Debug.Log("Construct BrightSpotsPass");

    this.profilerTag = profilerTag;
    this.renderPassEvent = renderPassEvent;
    this.brightsCompute = brightsCompute;
    this.flareMaterial = flareMaterial;
    this.renderTexture = renderTexture;
    if (!renderTexture.IsCreated())
    {
      Debug.LogWarning("RenderTexture wasn't created - doing now");
      renderTexture.Create();
    }

    findBrightsKernel = brightsCompute.FindKernel("FindBrights");
    colourTexID = Shader.PropertyToID("_colourTex");
    textureSizeXID = Shader.PropertyToID("_textureSizeX");
    textureSizeYID = Shader.PropertyToID("_textureSizeY");
    brightQuadsID = Shader.PropertyToID("_brightQuads");
    luminanceThresholdID = Shader.PropertyToID("_luminanceThreshold");

    brightsCompute.GetKernelThreadGroupSizes(findBrightsKernel,
      out uint sizeX, out uint sizeY, out var _);
    groupSizeX = (int)sizeX;
    groupSizeY = (int)sizeY;

    //TODO: buffer size here is arbitrary, decide on a maximum and enforce that
    brightsBuffer = new ComputeBuffer(100000, sizeof(float) * 16, ComputeBufferType.Append);
    drawArgsBuffer = new ComputeBuffer(4, sizeof(uint), ComputeBufferType.IndirectArguments);

    // this.renderTexture = new RenderTexture(1920, 1080, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.sRGB);

    drawArgsBuffer.SetData(new uint[] {
      6, // vertices per instance
      0, // instance count (will be set from brightsBuffer counter) 
      0, // byte offset of first vertex
      0, // byte offset of first instance
    });
  }

  public void Setup(
    RenderTargetIdentifier cameraColorIdent,
    RenderTargetIdentifier cameraDepthIdent,
    float luminanceThreshold,
    bool drawDirect,
    bool drawIndirect)
  {
    this.cameraColorIdent = cameraColorIdent;
    this.cameraDepthIdent = cameraDepthIdent;
    this.luminanceThreshold = luminanceThreshold;
    this.drawDirect = drawDirect;
    this.drawIndirect = drawIndirect;
  }

  // called each frame before Execute, use it to set up things the pass will need
  public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
  {
    this.cameraTextureDescriptor = cameraTextureDescriptor;
    brightsBuffer.SetCounterValue(0);
  }

  public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
  {
    // fetch a command buffer to use
    CommandBuffer cmd = CommandBufferPool.Get(profilerTag);
    cmd.Clear();

    // compute shader to find bright pixels anywhere on the image
    // when it finds a bright pixel, build the vertices of a two triangle mesh in brightsBuffer
    
    //TODO: rather than using camera's color target I'd like to use the "CameraOpaqueTexture" that URP generates
    cmd.SetComputeTextureParam(brightsCompute, findBrightsKernel, colourTexID, cameraColorIdent);
    cmd.SetComputeIntParam(brightsCompute, textureSizeXID, cameraTextureDescriptor.width);
    cmd.SetComputeIntParam(brightsCompute, textureSizeYID, cameraTextureDescriptor.height);
    cmd.SetComputeBufferParam(brightsCompute, findBrightsKernel, brightQuadsID, brightsBuffer);
    cmd.SetComputeFloatParam(brightsCompute, luminanceThresholdID, luminanceThreshold);
    cmd.DispatchCompute(brightsCompute, findBrightsKernel,
      Mathf.CeilToInt(cameraTextureDescriptor.width / groupSizeX),
      Mathf.CeilToInt(cameraTextureDescriptor.height / groupSizeY),
      1
    );

    // store how many brights were found into instanceCount slot of drawArgsBuffer
    cmd.CopyCounterValue(brightsBuffer, drawArgsBuffer, sizeof(uint));
    
    cmd.SetRenderTarget(cameraColorIdent);
    //TEMP: render to something else to see if it shows up there
    // cmd.SetRenderTarget(renderTexture);

    // draw the vertices generated by brightsCompute as a series of triangles
    MaterialPropertyBlock properties = new MaterialPropertyBlock();
    properties.SetBuffer(brightQuadsID, brightsBuffer);

    if (drawIndirect)
    {
      cmd.DrawProceduralIndirect(Matrix4x4.identity, flareMaterial, 0, MeshTopology.Triangles,
        drawArgsBuffer, 0, properties);
    }

    //TEMP: try using DrawProcedural, I guess.
    // This works! So finally, the problem must be with the drawArgsBuffer?
    // even though that looks to be totally fine. But still, something to work from!
    if (drawDirect)
    {
      cmd.DrawProcedural(Matrix4x4.identity, flareMaterial, 0, MeshTopology.Triangles,
        6, 10, properties);
    }

    cmd.SetRenderTarget(cameraColorIdent);

    // don't forget to tell ScriptableRenderContext to actually execute the commands
    context.ExecuteCommandBuffer(cmd);

    // tidy up after ourselves
    cmd.Clear();
    CommandBufferPool.Release(cmd);
  }

  // called after Execute, use it to clean up anything allocated in Configure
  public override void FrameCleanup(CommandBuffer cmd)
  {
    int[] countData = new int[1];
    drawArgsBuffer.GetData(countData);
    recentCount = countData[0];

    // Debug.Log(recentCount);
  }
}
