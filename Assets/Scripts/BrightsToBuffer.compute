#define GROUP_SIZE 8

#include "BrightPoint.hlsl"

Texture2D<float3> _sourceTexture;
AppendStructuredBuffer<BrightPoint> _brightPoints;
float _luminanceThreshold;

float CalculateLuminance(float3 colourLinear)
{
  // https://en.wikipedia.org/wiki/Relative_luminance
  return colourLinear.x * 0.2126 +
    colourLinear.y * 0.7152 +
    colourLinear.z * 0.0722;
}

BrightPoint MakeBrightPoint(int2 positionTexel, float3 colour, float luminance)
{
  BrightPoint p;
  p.middle = positionTexel;
  p.magnitude = (luminance - _luminanceThreshold) / _luminanceThreshold;
  p.colour = colour;
  p.luminance = luminance;
  p.padding = 0.0;
  return p;
}

groupshared BrightPoint cachedPoint[GROUP_SIZE][GROUP_SIZE];

#pragma kernel FindBrights
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void FindBrights (uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
  // every thread samples one texel
  float3 colour = _sourceTexture[globalId.xy];
  float luminance = CalculateLuminance(colour);

  cachedPoint[localId.x][localId.y] = MakeBrightPoint(
    globalId.xy, colour, luminance
  );
  GroupMemoryBarrierWithGroupSync();
  
  // Rather than having just one thread do the search, share the work somewhat.
  // There will still be at least 50% of threads inactive during this, with the
  // higher stride values having more inactive threads
  uint stride;
  for (stride = 2; stride <= GROUP_SIZE; stride *= 2)
  {
    if ((localId.x % stride) == 0)
    {
      if (cachedPoint[localId.x + stride / 2][localId.y].luminance >
          cachedPoint[localId.x][localId.y].luminance)
      {
        cachedPoint[localId.x][localId.y] = cachedPoint[localId.x + stride / 2][localId.y];
      }
    }
    GroupMemoryBarrierWithGroupSync();
  }
  // brightest in each row is now [0] of that row

  for (stride = 2; stride < GROUP_SIZE; stride *= 2)
  {
    if (localId.x == 0 && (localId.y % stride) == 0)
    {
      if (cachedPoint[0][localId.y + stride / 2].luminance >
          cachedPoint[0][localId.y].luminance)
      {
        cachedPoint[0][localId.y] = cachedPoint[0][localId.y + stride / 2];
      }
    }
    // group sync must be outside of any conditionals, even the idle threads need to reach it
    GroupMemoryBarrierWithGroupSync();
  }
  // brightest in whole group is now in [0][0]
  
  // final step is always only done on one thread as want to add at most one to _brightPoints
  if (localId.x == 0 && localId.y == 0)
  {
    BrightPoint brightest = cachedPoint[0][0];
    if (brightest.luminance > _luminanceThreshold)
    {
      _brightPoints.Append(brightest);
    }
  }
}
