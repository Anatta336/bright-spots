// note that GROUP_SIZE has a significant impact on how the results look
#define GROUP_SIZE 12

#include "BrightQuad.hlsl"

Texture2D<float3> _colourTex;
int _textureSizeX;
int _textureSizeY;
AppendStructuredBuffer<BrightQuad> _brightQuads;
float _luminanceThreshold;

float CalculateLuminance(float3 colourLinear)
{
  return colourLinear.x * 0.2126 +
    colourLinear.y * 0.7152 +
    colourLinear.z * 0.0722;
}

BrightQuad MakeBrightQuad(int2 positionTexel, float3 colour)
{
  /*
    v0 ──── v1,v4
    │      ╱ │
    │     ╱  │
    │    ╱   │
    │   ╱    │
    │  ╱     │
    │ ╱      │
  v2,v3 ───  v5
  */

  float2 mid = float2(
    (float(positionTexel.x) / _textureSizeX) * 2.0 - 1.0,
    (1.0 - (float(positionTexel.y) / _textureSizeY)) * 2.0 - 1.0
  );
  float2 size = float2(0.1, 0.1);
  BrightQuad p;

  p.v0 = mid + float2(-size.x,  size.y);
  p.v1 = mid + float2( size.x,  size.y);
  p.v2 = mid + float2(-size.x, -size.y);

  p.v3 = mid + float2(-size.x, -size.y);
  p.v4 = mid + float2( size.x,  size.y);
  p.v5 = mid + float2( size.x, -size.y);

  p.colour = colour;
  p.padding = 0.0;
  return p;
}

// groupshared variables are accessible by every thread in a group
groupshared uint brightestLuminanceUint = 0;
groupshared float3 colourOfBrightest;
groupshared int2 texelPosOfBrightest;

groupshared float cachedLuminance[GROUP_SIZE][GROUP_SIZE];
groupshared float3 cachedColour[GROUP_SIZE][GROUP_SIZE];

#define LUMINANCE_TO_UINT 10000000

#pragma kernel FindBrights
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void FindBrights (uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
  // every pixel gets its luminance calculated and stored by a thread each
  float3 colourHere = _colourTex[globalId.xy];
  float luminanceHere = CalculateLuminance(colourHere);
  cachedColour[localId.x][localId.y] = colourHere;
  cachedLuminance[localId.x][localId.y] = luminanceHere;

  // wait for everyone to write to cache
  GroupMemoryBarrier();

  // all but one thread will stop here
  if (!(localId.x == 0 && localId.y == 0))
  {
    return;
  }
  
  // the one remaining thread finds the highest luminance in the group
  bool foundBright = false;
  float brightest = _luminanceThreshold;
  float3 brightestColour;
  int2 brightestLocation;
  for (int y = 0; y < GROUP_SIZE; ++y)
  for (int x = 0; x < GROUP_SIZE; ++x)
  {
    float luminance = cachedLuminance[x][y];
    if (luminance > brightest)
    {
      foundBright = true;
      brightest = luminance;
      brightestColour = cachedColour[x][y];
      brightestLocation = int2(x, y);
    }
  }

  if (foundBright)
  {
    _brightQuads.Append(MakeBrightQuad(
      int2(
        groupId.x * GROUP_SIZE + brightestLocation.x,
        groupId.y * GROUP_SIZE + brightestLocation.y),
      brightestColour
    ));
  }
}
