#define GROUP_SIZE 4
#define REGION_PER_THREAD 2

#include "BrightPoint.hlsl"

Texture2D<float3> _sourceTexture;
AppendStructuredBuffer<BrightPoint> _brightPoints;
float _luminanceThreshold;

float CalculateLuminance(float3 colourLinear)
{
  // https://en.wikipedia.org/wiki/Relative_luminance
  return colourLinear.x * 0.2126 +
    colourLinear.y * 0.7152 +
    colourLinear.z * 0.0722;
}

BrightPoint MakeBrightPoint(int2 positionTexel, float3 colour, float luminance)
{
  BrightPoint p;
  p.middle = positionTexel;
  p.magnitude = (luminance - _luminanceThreshold) / _luminanceThreshold;
  p.colour = colour;
  p.luminance = luminance;
  p.padding = 0.0;
  return p;
}

groupshared BrightPoint cachedPoint[GROUP_SIZE][GROUP_SIZE];

#pragma kernel FindBrights
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void FindBrights (uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
  // every thread examines a square of REGION_PER_THREAD x REGION_PER_THREAD texels
  BrightPoint brightest = MakeBrightPoint(int2(0,0), float3(0,0,0), _luminanceThreshold);
  int xStart = globalId.x * REGION_PER_THREAD;
  int yStart = globalId.y * REGION_PER_THREAD;
  for (int y = yStart; y < yStart + REGION_PER_THREAD; ++y)
  for (int x = xStart; x < xStart + REGION_PER_THREAD; ++x)
  {
    float3 colour = _sourceTexture[int2(x, y)];
    float luminance = CalculateLuminance(colour);
    if (luminance > brightest.luminance)
    {
      brightest = MakeBrightPoint(int2(x, y), colour, luminance);
    }
  }

  cachedPoint[localId.x][localId.y] = brightest;
  GroupMemoryBarrierWithGroupSync();
  
  // search for brightest in each row
  uint stride;
  for (stride = 2; stride <= GROUP_SIZE; stride *= 2)
  {
    if ((localId.x % stride) == 0)
    {
      if (cachedPoint[localId.x + stride / 2][localId.y].luminance >
          cachedPoint[localId.x][localId.y].luminance)
      {
        cachedPoint[localId.x][localId.y] = cachedPoint[localId.x + stride / 2][localId.y];
      }
    }
    GroupMemoryBarrierWithGroupSync();
  }
  // brightest in each row is now [0] of that row

  for (stride = 2; stride <= GROUP_SIZE; stride *= 2)
  {
    if (localId.x == 0 && (localId.y % stride) == 0)
    {
      if (cachedPoint[0][localId.y + stride / 2].luminance >
          cachedPoint[0][localId.y].luminance)
      {
        cachedPoint[0][localId.y] = cachedPoint[0][localId.y + stride / 2];
      }
    }
    // group sync must be outside of any conditionals, even the idle threads need to reach it
    GroupMemoryBarrierWithGroupSync();
  }
  // brightest in whole group is now in [0][0]
  
  // final step is always only done on one thread as want to add at most one to _brightPoints
  if (localId.x == 0 && localId.y == 0)
  {
    BrightPoint brightest = cachedPoint[0][0];
    if (brightest.luminance > _luminanceThreshold)
    {
      _brightPoints.Append(brightest);
    }
  }
}
