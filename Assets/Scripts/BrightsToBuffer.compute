#define GROUP_SIZE 32
#define REGION_PER_THREAD 8

#include "BrightPoint.hlsl"

Texture2D<float3> _sourceTexture;
AppendStructuredBuffer<BrightPoint> _brightPoints;
float _luminanceThreshold;

float CalculateLuminance(float3 colourLinear)
{
  // https://en.wikipedia.org/wiki/Relative_luminance
  return colourLinear.x * 0.2126 +
    colourLinear.y * 0.7152 +
    colourLinear.z * 0.0722;
}

BrightPoint MakeBrightPoint(int2 positionTexel, float3 colour, float luminance)
{
  BrightPoint p;
  p.middle = positionTexel;
  p.magnitude = (luminance - _luminanceThreshold) / _luminanceThreshold;
  p.colour = colour;
  p.luminance = luminance;
  p.padding = 0.0;
  return p;
}

#pragma kernel FindBrights
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void FindBrights (uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
  // every thread examines a square of REGION_PER_THREAD x REGION_PER_THREAD texels

  BrightPoint brightest = MakeBrightPoint(int2(0,0), float3(0,0,0), _luminanceThreshold);
  bool foundBright = false;

  int xStart = globalId.x * REGION_PER_THREAD;
  int yStart = globalId.y * REGION_PER_THREAD;
  for (int y = yStart; y < yStart + REGION_PER_THREAD; ++y)
  for (int x = xStart; x < xStart + REGION_PER_THREAD; ++x)
  {
    float3 colour = _sourceTexture[int2(x, y)];
    float luminance = CalculateLuminance(colour);
    if (luminance > brightest.luminance)
    {
      brightest = MakeBrightPoint(int2(x, y), colour, luminance);
      foundBright = true;
    }
  }
  if (foundBright)
  {
    _brightPoints.Append(brightest);
  }
}
